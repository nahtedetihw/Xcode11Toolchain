// -*- Metal -*-
//===-- metal_texture -----------------------------------------------------===//
// Copyright (c) 2014-2019 Apple Inc. All rights reserved
//===----------------------------------------------------------------------===//

#ifndef __METAL_TEXTURE
#define __METAL_TEXTURE

#if defined(__HAVE_ARRAY__)
#include <metal_array>
#endif
#if defined(__HAVE_IMAGEBLOCKS__)
#include <metal_imageblocks>
#endif
#include <metal_type_traits>

#pragma METAL internals : enable
namespace metal {
enum class access
{
  sample = __METAL_ACCESS_SAMPLE__,
  read = __METAL_ACCESS_READ__,
  write = __METAL_ACCESS_WRITE__,
#if defined(__HAVE_TEXTURE_READWRITE__)
  read_write = __METAL_ACCESS_READ_WRITE__
#endif
};

enum class coord
{
  normalized = __METAL_COORD_NORMALIZED__,
  pixel = __METAL_COORD_PIXEL__
};
enum class filter
{
  nearest = __METAL_FILTER_NEAREST__,
  linear = __METAL_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_FILTER_BICUBIC__
#endif
};
enum class s_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
};
enum class t_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
};
enum class r_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
};
enum class address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
};
enum class mip_filter
{
  none = __METAL_MIP_FILTER_NONE__,
  nearest = __METAL_MIP_FILTER_NEAREST__,
  linear = __METAL_MIP_FILTER_LINEAR__
};
enum class compare_func
{
#if defined(__HAVE_NONE_COMPARE_FUNCTION__)
  none = __METAL_COMPARE_FUNC_NONE__,
#endif
  less = __METAL_COMPARE_FUNC_LESS__,
  less_equal = __METAL_COMPARE_FUNC_LESS_EQUAL__,
  greater = __METAL_COMPARE_FUNC_GREATER__,
  greater_equal = __METAL_COMPARE_FUNC_GREATER_EQUAL__,
  equal = __METAL_COMPARE_FUNC_EQUAL__,
  not_equal = __METAL_COMPARE_FUNC_NOT_EQUAL__,
#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
  always = __METAL_COMPARE_FUNC_ALWAYS__,
  never = __METAL_COMPARE_FUNC_NEVER__
#endif
};
enum class mag_filter
{
  nearest = __METAL_MAG_FILTER_NEAREST__,
  linear = __METAL_MAG_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MAG_FILTER_BICUBIC__
#endif
};
enum class min_filter
{
  nearest = __METAL_MIN_FILTER_NEAREST__,
  linear = __METAL_MIN_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MIN_FILTER_BICUBIC__
#endif
};

struct __max_anisotropy
{
  METAL_FUNC constexpr explicit __max_anisotropy(int v) thread
      : value(v - 1) // Given value 1 to 16 is stored as 4 bits 0 to 15.
  {
  }
  uchar value : 4;
};
struct __lod_clamp
{
  METAL_FUNC constexpr explicit __lod_clamp(float min, float max) thread
      : bits((convert(max) << 16) | convert(min))
  {
  }
  uint bits;

private:
  METAL_FUNC static constexpr float clamp(float x, float absmax)
  {
    return (x > absmax) ? absmax : (x < -absmax) ? -absmax : x;
  }
  METAL_FUNC static constexpr uint convert(float x)
  {
    return as_type<ushort>(static_cast<half>(__builtin_isfinite(x) ? clamp(x, HALF_MAX) : x));
  }
};

#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
using max_anisotropy = __max_anisotropy;
using lod_clamp = __lod_clamp;
#endif


#if defined(__HAVE_SAMPLER_REDUCTION__)
enum class reduction
{
  weighted_average = __METAL_REDUCTION_WEIGHTED_AVERAGE__,
  minimum = __METAL_REDUCTION_MINIMUM__,
  maximum = __METAL_REDUCTION_MAXIMUM__
};
#endif

// Metal 1.1 s2.6: Samplers.
struct sampler
{
public:
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread sampler& operator&() const thread = delete;
#endif
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant sampler& operator&() const constant = delete;
#endif

  METAL_FUNC constexpr sampler() thread : val(build())
  {
  }
  template <typename... Ts>
  METAL_FUNC constexpr sampler(Ts... t) thread : val(build(t...))
  {
  }
  METAL_FUNC constexpr sampler() constant : val(build())
  {
  }
  template <typename... Ts>
  METAL_FUNC constexpr sampler(Ts... t) constant : val(build(t...))
  {
  }

  METAL_FUNC constexpr sampler(const thread sampler &) thread = default;
  METAL_FUNC constexpr sampler(const constant sampler &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) thread = default;
#endif
  METAL_FUNC constexpr sampler(const thread sampler &) constant = default;
  METAL_FUNC constexpr sampler(const constant sampler &) constant = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) constant = default;
#endif

#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const thread sampler &that) thread = default;
#else
  thread sampler &operator=(const thread sampler&) thread = delete;
#endif
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const constant sampler &that) thread = default;
#else
  thread sampler &operator=(const constant sampler&) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const device sampler &that) thread = default;
#else
  thread sampler &operator=(const device sampler&) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const thread sampler &that) device = default;
#else
  device sampler &operator=(const thread sampler&) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const constant sampler &that) device = default;
#else
  device sampler &operator=(const constant sampler&) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const device sampler &that) device = default;
#else
  device sampler &operator=(const device sampler&) device = delete;
#endif
#endif

private :
  __metal_sampler_t val;

private:
  // Values to help calculate offsets.
  constexpr const static constant unsigned s_address_bits  =  3;   // bits[2:0]   s_address mode
  constexpr const static constant unsigned t_address_bits  =  3;   // bits[5:3]   t_address mode
  constexpr const static constant unsigned r_address_bits  =  3;   // bits[8:6]   r_address mode
  constexpr const static constant unsigned mag_filter_bits =  2;   // bits[10:9]  mag filter mode
  constexpr const static constant unsigned min_filter_bits =  2;   // bits[12:11] min filter mode
  constexpr const static constant unsigned mip_filter_bits =  2;   // bits[14:13] mip filter mode
  constexpr const static constant unsigned normalized_bits =  1;   // bits[15:15] normalized mode
  constexpr const static constant unsigned compare_bits    =  4;   // bits[19:16] compare func
  constexpr const static constant unsigned anisotropy_bits =  4;   // bits[23:20] max anisotropy level
  constexpr const static constant unsigned lod_clamp_bits  = 32;   // bits[39:24] lod min value
                                                                   // bits[55:40] lod max value
  constexpr const static constant unsigned border_color_bits =  2; // bits[57:56] border_color
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant unsigned reduction_bits    =  2; // bits[59:58] reduction
                                                                   // bits[62:60] reserved
#endif
  constexpr const static constant unsigned marker_bit        = 63; // bits[63:63] constant sampler indicator.

  constexpr const static constant unsigned s_address_base    = 0;
  constexpr const static constant unsigned t_address_base    = s_address_base  + s_address_bits;
  constexpr const static constant unsigned r_address_base    = t_address_base  + t_address_bits;
  constexpr const static constant unsigned mag_filter_base   = r_address_base  + r_address_bits;
  constexpr const static constant unsigned min_filter_base   = mag_filter_base + mag_filter_bits;
  constexpr const static constant unsigned mip_filter_base   = min_filter_base + min_filter_bits;
  constexpr const static constant unsigned normalized_base   = mip_filter_base + mip_filter_bits;
  constexpr const static constant unsigned compare_base      = normalized_base + normalized_bits;
  constexpr const static constant unsigned anisotropy_base   = compare_base    + compare_bits;
  constexpr const static constant unsigned lod_clamp_base    = anisotropy_base + anisotropy_bits;
  constexpr const static constant unsigned border_color_base = lod_clamp_base + lod_clamp_bits;
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant unsigned reduction_base    = border_color_base + border_color_bits;
#endif

  constexpr const static constant ulong s_address_mask    = ((1UL << s_address_bits   ) - 1) << s_address_base;
  constexpr const static constant ulong t_address_mask    = ((1UL << t_address_bits   ) - 1) << t_address_base;
  constexpr const static constant ulong r_address_mask    = ((1UL << r_address_bits   ) - 1) << r_address_base;
  constexpr const static constant ulong mag_filter_mask   = ((1UL << mag_filter_bits  ) - 1) << mag_filter_base;
  constexpr const static constant ulong min_filter_mask   = ((1UL << min_filter_bits  ) - 1) << min_filter_base;
  constexpr const static constant ulong mip_filter_mask   = ((1UL << mip_filter_bits  ) - 1) << mip_filter_base;
  constexpr const static constant ulong normalized_mask   = ((1UL << normalized_bits  ) - 1) << normalized_base;
  constexpr const static constant ulong compare_mask      = ((1UL << compare_bits     ) - 1) << compare_base;
  constexpr const static constant ulong anisotropy_mask   = ((1UL << anisotropy_bits  ) - 1) << anisotropy_base;
  constexpr const static constant ulong lod_clamp_mask    = ((1UL << lod_clamp_bits   ) - 1) << lod_clamp_base;
  constexpr const static constant ulong border_color_mask = ((1UL << border_color_bits) - 1) << border_color_base;
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant ulong reduction_mask    = ((1UL << reduction_bits   ) - 1) << reduction_base;
#endif

#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
  constexpr const static constant compare_func default_compare_func = compare_func::never;
#else
  constexpr const static constant compare_func default_compare_func = compare_func::none;
#endif
  constexpr const static constant auto default_anisotropy = __max_anisotropy(1);
  constexpr const static constant auto default_lod_clamp = __lod_clamp(0.0, FLT_MAX);

  static constexpr ulong build()
  {
    return (ulong(1) << marker_bit) |
           (ulong(default_lod_clamp.bits) << lod_clamp_base) |
           (ulong(default_anisotropy.value) << anisotropy_base) |
           (ulong(default_compare_func) << compare_base) |
           (ulong(address::clamp_to_edge) << s_address_base) |
           (ulong(address::clamp_to_edge) << t_address_base) |
           (ulong(address::clamp_to_edge) << r_address_base);
  }

  template <typename... Ts>
  static constexpr ulong build(coord mode, Ts... t)
  {
    return (ulong(mode) << normalized_base) | (build(t...) & ~normalized_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(s_address mode, Ts... t)
  {
    return (ulong(mode) << s_address_base) | (build(t...) & ~s_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(t_address mode, Ts... t)
  {
    return (ulong(mode) << t_address_base) | (build(t...) & ~t_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(r_address mode, Ts... t)
  {
    return (ulong(mode) << r_address_base) | (build(t...) & ~r_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(address mode, Ts... t)
  {
    return (ulong(mode) << s_address_base) |
           (ulong(mode) << t_address_base) |
           (ulong(mode) << r_address_base) |
           (build(t...) & ~(s_address_mask | t_address_mask | r_address_mask));
  }

  template <typename... Ts>
  static constexpr ulong build(mag_filter mode, Ts... t)
  {
    return (ulong(mode) << mag_filter_base) | (build(t...) & ~mag_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(min_filter mode, Ts... t)
  {
    return (ulong(mode) << min_filter_base) | (build(t...) & ~min_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(filter mode, Ts... t)
  {
    return (ulong(mode) << mag_filter_base) |
           (ulong(mode) << min_filter_base) |
           (build(t...) & ~(mag_filter_mask | min_filter_mask));
  }

  template <typename... Ts>
  static constexpr ulong build(mip_filter mode, Ts... t)
  {
    return (ulong(mode) << mip_filter_base) | (build(t...) & ~mip_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(compare_func mode, Ts... t)
  {
    return (ulong(mode) << compare_base) | (build(t...) & ~compare_mask);
  }

#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
  template <typename... Ts>
  static constexpr ulong build(max_anisotropy aniso, Ts... t)
  {
    return (ulong(aniso.value) << anisotropy_base) | (build(t...) & ~anisotropy_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(lod_clamp lod, Ts... t)
  {
    return (ulong(lod.bits) << lod_clamp_base) | (build(t...) & ~lod_clamp_mask);
  }
#endif


#if defined(__HAVE_SAMPLER_REDUCTION__)
  template <typename... Ts>
  static constexpr ulong build(reduction mode, Ts... t)
  {
    return (ulong(mode) << reduction_base) | (build(t...) & ~reduction_mask);
  }
#endif

private:
  template <typename T, access a, typename _Enable>
  friend struct texture1d;
  template <typename T, access a, typename _Enable>
  friend struct texture1d_array;
  template <typename T, access a, typename _Enable>
  friend struct texture2d;
  template <typename T, access a, typename _Enable>
  friend struct texture2d_array;
  template <typename T, access a, typename _Enable>
  friend struct texture3d;
  template <typename T, access a, typename _Enable>
  friend struct texturecube;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct texturecube_array;
#endif
  template <typename T, access a, typename _Enable>
  friend struct texture2d_ms;
  template <typename T, access a, typename _Enable>
  friend struct depth2d;
  template <typename T, access a, typename _Enable>
  friend struct depth2d_array;
  template <typename T, access a, typename _Enable>
  friend struct depthcube;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct depthcube_array;
#endif
  template <typename T, access a, typename _Enable>
  friend struct depth2d_ms;
};

#if defined(__HAVE_SPARSE_TEXTURES__)
template <typename T, typename _E = typename enable_if<is_arithmetic<make_scalar_t<T>>::value>::type>
struct sparse_color {
public:
  METAL_FUNC constexpr sparse_color(T value, bool resident) thread
      : color_value(value), from_resident_pages(resident)
  {
  }

  // Indicates whether all memory addressed to retrieve the value was mapped.
  METAL_FUNC constexpr bool resident() const thread
  {
    return from_resident_pages;
  }
  METAL_FUNC constexpr T const value() const thread
  {
    return color_value;
  }

private:
  T color_value;
  ulong from_resident_pages : 1;
  ulong reserved : 63;

};
#endif

struct bias
{
  METAL_FUNC constexpr bias(float value) thread
      : value(value)
  {
  }
  float value;
};

struct level
{
  METAL_FUNC constexpr level(float lod) thread
      : lod(lod)
  {
  }
  float lod;
};

#if defined(__HAVE_MIN_LOD_CLAMP__)
struct min_lod_clamp
{
  METAL_FUNC constexpr min_lod_clamp(float value) thread
      : value(value)
  {
  }
  float value;
};
#endif

// To allow level to be used in constant argument checks.
template <>
struct _constarg_traits<level>
{
  constexpr static METAL_INTERNAL bool check(level l)
  {
    return _constarg_traits<float>::check(l.lod);
  }
};

struct gradient2d
{
  METAL_FUNC constexpr gradient2d(float2 dPdx, float2 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float2 dPdx;
  float2 dPdy;
};

struct gradient3d
{
  METAL_FUNC constexpr gradient3d(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

struct gradientcube
{
  METAL_FUNC constexpr gradientcube(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

enum class component
{
  x,
  y,
  z,
  w
};

METAL_INTERNAL constexpr static inline bool _is_zero(uint a)
{
  return a == 0;
}
METAL_INTERNAL constexpr static inline bool _is_zero(level a)
{
  return a.lod == 0;
}
#define METAL_ZERO_ARG(A) \
  METAL_ENABLE_IF(_is_zero(A), "'" #A "' argument value must be 0")

#define METAL_VALID_LOD_ARG(A)

#define METAL_VALID_LEVEL_ARG(A)

// Metal 1.1 s2.5: Textures.
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture3d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct texture2d_ms;
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a = access::read, typename _Enable = void>
struct texture_buffer;
#endif
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct depth2d_ms;

#if defined(__HAVE_NULL_TEXTURE__)
// Metal 1.2 s5.10.15: Null Texture Functions.
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture3d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube<T, a> tex);
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex);
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube<T, a> tex);
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex);
#endif

template <typename T>
struct _is_color_texture_channel_impl : bool_constant<__is_metal_color_texture_channel(T)>
{
};

template <typename T>
struct is_color_texture_channel : _is_color_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_color_texture_channel_v = is_color_texture_channel<T>::value;
#endif

#if defined(__HAVE_IMAGEBLOCKS__)
template <typename E, typename T>
struct _is_color_texture_imageblock_slice_storage_valid_impl : bool_constant<__is_metal_color_texture_imageblock_slice_storage_valid(E, T)>
{
};

template <typename E, typename T>
struct is_color_texture_imageblock_slice_storage_valid : _is_color_texture_imageblock_slice_storage_valid_impl<remove_cv_t<E>, remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename E, typename T>
constexpr constant bool is_color_texture_imageblock_slice_storage_valid_v = is_color_texture_imageblock_slice_storage_valid<E, T>::value;
#endif
#endif

template <typename T>
struct _is_depth_texture_channel_impl : bool_constant<__is_metal_depth_texture_channel(T)>
{
};

template <typename T>
struct is_depth_texture_channel : _is_depth_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_depth_texture_channel_v = is_depth_texture_channel<T>::value;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_default_construct(_a) (_a == access::read || _a == access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_default_construct(_a) (_a == access::read || _a == access::sample || _a == access::write)
#else
#define _is_valid_default_construct(_a) (_a == access::read || _a == access::sample || _a == access::write || _a == access::read_write)
#endif
#define _err_default_construct_msg "Default constructor for textures must use access::sample or access::read as the access qualifier"
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_copy_assign(_a) (_a == access::read || _a == access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_copy_assign(_a) (_a == access::read || _a == access::sample || _a == access::write)
#else
#define _is_valid_copy_assign(_a) (_a == access::read || _a == access::sample || _a == access::write || _a == access::read_write)
#endif
#define _err_copy_assign_msg "Assignment of textures supports only texture with access::sample or access::read access qualifier"
#endif

#define _is_valid_sample(_a) (_a == access::sample)
#define _err_sample_access_msg "Texture sampling supports only texture with access::sample access qualifier"

#if defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_read(_a) (_a == access::sample || _a == access::read || _a == access::read_write)
#define _err_read_access_msg "Texture reading supports only texture with access::sample, access::read, or access::read_write as the access qualifier"
#define _is_valid_write(_a) (_a == access::write || _a == access::read_write)
#define _err_write_access_msg "Texture writing supports only texture with access::write or access::read_write as the access qualifier"
#else
#define _is_valid_read(_a) (_a == access::sample || _a == access::read)
#define _err_read_access_msg "Texture reading supports only texture with access::read or access::sample as the access qualifier"
#define _is_valid_write(_a) (_a == access::write)
#define _err_write_access_msg "Texture writing supports only texture with access::write or access::read_write as the access qualifier"
#endif

#define _is_valid_gather(_a) (_a == access::sample)
#define _err_gather_access_msg "Texture gather supports only texture with access::sample access qualifier"

#define _is_valid_ms_access(_a) (_a == access::read)
#define _err_ms_access "Multisample textures must have access qualifier access::read"

#define _is_valid_texture_buffer_access(_a) (_a == access::read || _a == access::write || _a == access::read_write)
#define _err_texture_buffer_access "Texture buffers must have access qualifier access::read, access::write, or access::read_write"

#define _is_valid_depth_access(_a) (_a == access::sample || _a == access::read)
#define _err_depth_access "Depth textures must have access qualifier access::read or access::sample"

#if defined(__HAVE_IMAGEBLOCKS__)
#define _is_valid_imageblock_slice_write(_e, _t) (is_color_texture_imageblock_slice_storage_valid_v<_e, _t>)
#define _err_imageblock_slice_write_msg "The channel type of the texture must match the element type of the slice type"
#endif

template <typename T, access a>
struct texture1d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d<T, a> &operator&() const thread = delete;
#endif

  const thread texture1d<T, a> &operator,(const thread texture1d<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d<T, a> &operator,(const device texture1d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d<T, a> &operator,(const constant texture1d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d<T, a> &operator,(const thread texture1d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d<T, a> &operator,(const device texture1d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d<T, a> &operator,(const constant texture1d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d<T, a> &operator,(const thread texture1d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d<T, a> &operator,(const device texture1d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d<T, a> &operator,(const constant texture1d<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture1d() thread : t(__metal_get_null_texture_1d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture1d() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture1d() constant : t(__metal_get_null_texture_1d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture1d() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d<T, a> &operator=(const thread texture1d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d<T, a> &operator=(const thread texture1d<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d<T, a> &operator=(const device texture1d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d<T, a> &operator=(const device texture1d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d<T, a> &operator=(const constant texture1d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d<T, a> &operator=(const constant texture1d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d<T, a> &operator=(const thread texture1d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d<T, a> &operator=(const thread texture1d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d<T, a> &operator=(const device texture1d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d<T, a> &operator=(const device texture1d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d<T, a> &operator=(const constant texture1d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d<T, a> &operator=(const constant texture1d<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_t(t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_1d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_1d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_1d_t(t);
  }
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_1d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_1d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_1d_t(t);
  }
#endif

private:
  __metal_texture_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d<T, a>);
#endif
};

template<typename T, access a>
struct texture1d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d_array<T, a> &operator&() const thread = delete;
#endif

  const thread texture1d_array<T, a> &operator,(const thread texture1d_array<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d_array<T, a> &operator,(const device texture1d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d_array<T, a> &operator,(const constant texture1d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d_array<T, a> &operator,(const thread texture1d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d_array<T, a> &operator,(const device texture1d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d_array<T, a> &operator,(const constant texture1d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture1d_array<T, a> &operator,(const thread texture1d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture1d_array<T, a> &operator,(const device texture1d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture1d_array<T, a> &operator,(const constant texture1d_array<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture1d_array() thread : t(__metal_get_null_texture_1d_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture1d_array() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture1d_array() constant : t(__metal_get_null_texture_1d_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture1d_array() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d_array<T, a> &operator=(const thread texture1d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d_array<T, a> &operator=(const thread texture1d_array<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d_array<T, a> &operator=(const device texture1d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d_array<T, a> &operator=(const device texture1d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture1d_array<T, a> &operator=(const constant texture1d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture1d_array<T, a> &operator=(const constant texture1d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d_array<T, a> &operator=(const thread texture1d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d_array<T, a> &operator=(const thread texture1d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d_array<T, a> &operator=(const device texture1d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d_array<T, a> &operator=(const device texture1d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture1d_array<T, a> &operator=(const constant texture1d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture1d_array<T, a> &operator=(const constant texture1d_array<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_1d_array_t(t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_1d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_1d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_1d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_1d_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_1d_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_1d_array_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    return __metal_get_array_size_texture_1d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_1d_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    return __metal_get_array_size_texture_1d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_1d_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    return __metal_get_width_texture_1d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    return __metal_get_array_size_texture_1d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_1d_array_t(t);
  }
#endif

private:
  __metal_texture_1d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d_array<T, a>);
#endif
};

template<typename T, access a>
struct texture2d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d<T, a> &operator&() const thread = delete;
#endif

  const thread texture2d<T, a> &operator,(const thread texture2d<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d<T, a> &operator,(const device texture2d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d<T, a> &operator,(const constant texture2d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d<T, a> &operator,(const thread texture2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d<T, a> &operator,(const device texture2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d<T, a> &operator,(const constant texture2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d<T, a> &operator,(const thread texture2d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d<T, a> &operator,(const device texture2d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d<T, a> &operator,(const constant texture2d<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d() thread : t(__metal_get_null_texture_2d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture2d() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d() constant : t(__metal_get_null_texture_2d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture2d() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d<T, a> &operator=(const thread texture2d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d<T, a> &operator=(const thread texture2d<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d<T, a> &operator=(const device texture2d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d<T, a> &operator=(const device texture2d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d<T, a> &operator=(const constant texture2d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d<T, a> &operator=(const constant texture2d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d<T, a> &operator=(const thread texture2d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d<T, a> &operator=(const thread texture2d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d<T, a> &operator=(const device texture2d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d<T, a> &operator=(const device texture2d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d<T, a> &operator=(const constant texture2d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d<T, a> &operator=(const constant texture2d<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_t(t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_2d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_2d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_2d_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_2d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_2d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_texture_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_2d_t(t);
  }
#endif

private:
  __metal_texture_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d<T, a>);
#endif
};

template<typename T, access a>
struct texture2d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_array<T, a> &operator&() const thread = delete;
#endif

  const thread texture2d_array<T, a> &operator,(const thread texture2d_array<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_array<T, a> &operator,(const device texture2d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_array<T, a> &operator,(const constant texture2d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_array<T, a> &operator,(const thread texture2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_array<T, a> &operator,(const device texture2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_array<T, a> &operator,(const constant texture2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_array<T, a> &operator,(const thread texture2d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_array<T, a> &operator,(const device texture2d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_array<T, a> &operator,(const constant texture2d_array<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d_array() thread : t(__metal_get_null_texture_2d_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture2d_array() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d_array() constant : t(__metal_get_null_texture_2d_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture2d_array() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_array<T, a> &operator=(const thread texture2d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d_array<T, a> &operator=(const thread texture2d_array<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_array<T, a> &operator=(const device texture2d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d_array<T, a> &operator=(const device texture2d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_array<T, a> &operator=(const constant texture2d_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture2d_array<T, a> &operator=(const constant texture2d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_array<T, a> &operator=(const thread texture2d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d_array<T, a> &operator=(const thread texture2d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_array<T, a> &operator=(const device texture2d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d_array<T, a> &operator=(const device texture2d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_array<T, a> &operator=(const constant texture2d_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture2d_array<T, a> &operator=(const constant texture2d_array<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_array_t(t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_2d_array_t(t, coord, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_2d_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_2d_array_t(t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_2d_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_2d_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_2d_array_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    return __metal_get_array_size_texture_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_2d_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    return __metal_get_array_size_texture_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_2d_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_texture_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    return __metal_get_array_size_texture_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_2d_array_t(t);
  }
#endif

private:
  __metal_texture_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_array<T, a>);
#endif
};

template<typename T, access a>
struct texture3d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture3d<T, a> &operator&() const thread = delete;
#endif

  const thread texture3d<T, a> &operator,(const thread texture3d<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture3d<T, a> &operator,(const device texture3d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture3d<T, a> &operator,(const constant texture3d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture3d<T, a> &operator,(const thread texture3d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture3d<T, a> &operator,(const device texture3d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture3d<T, a> &operator,(const constant texture3d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture3d<T, a> &operator,(const thread texture3d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture3d<T, a> &operator,(const device texture3d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture3d<T, a> &operator,(const constant texture3d<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture3d() thread : t(__metal_get_null_texture_3d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture3d() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture3d() constant : t(__metal_get_null_texture_3d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture3d() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture3d<T, a> &operator=(const thread texture3d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture3d<T, a> &operator=(const thread texture3d<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture3d<T, a> &operator=(const device texture3d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture3d<T, a> &operator=(const device texture3d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture3d<T, a> &operator=(const constant texture3d<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture3d<T, a> &operator=(const constant texture3d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture3d<T, a> &operator=(const thread texture3d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture3d<T, a> &operator=(const thread texture3d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture3d<T, a> &operator=(const device texture3d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture3d<T, a> &operator=(const device texture3d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture3d<T, a> &operator=(const constant texture3d<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture3d<T, a> &operator=(const constant texture3d<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_3d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_3d_t(t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    __metal_write_texture_3d_t(t, coord, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_3d_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_3d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_3d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_3d_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const thread
  {
    return __metal_get_depth_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_3d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const device
  {
    return __metal_get_depth_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_3d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const constant
  {
    return __metal_get_depth_texture_3d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_3d_t(t);
  }
#endif

private:
  __metal_texture_3d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture3d<T, a>);
#endif
};

template<typename T, access a>
struct texturecube<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube<T, a> &operator&() const thread = delete;
#endif

  const thread texturecube<T, a> &operator,(const thread texturecube<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube<T, a> &operator,(const device texturecube<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube<T, a> &operator,(const constant texturecube<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube<T, a> &operator,(const thread texturecube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube<T, a> &operator,(const device texturecube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube<T, a> &operator,(const constant texturecube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube<T, a> &operator,(const thread texturecube<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube<T, a> &operator,(const device texturecube<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube<T, a> &operator,(const constant texturecube<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texturecube() thread : t(__metal_get_null_texture_cube_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texturecube() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texturecube() constant : t(__metal_get_null_texture_cube_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texturecube() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube<T, a> &operator=(const thread texturecube<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube<T, a> &operator=(const thread texturecube<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube<T, a> &operator=(const device texturecube<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube<T, a> &operator=(const device texturecube<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube<T, a> &operator=(const constant texturecube<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube<T, a> &operator=(const constant texturecube<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube<T, a> &operator=(const thread texturecube<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube<T, a> &operator=(const thread texturecube<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube<T, a> &operator=(const device texturecube<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube<T, a> &operator=(const device texturecube<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube<T, a> &operator=(const constant texturecube<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube<T, a> &operator=(const constant texturecube<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif

#if defined(__HAVE_TEXTURE_CUBE_READ__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_t(t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif

#if defined(__HAVE_TEXTURE_CUBE_WRITE__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_t(t, coord, face, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_t(t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_cube_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_cube_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_cube_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_cube_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_cube_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_texture_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_cube_t(t);
  }
#endif

private:
  __metal_texture_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube<T, a>);
#endif
};

#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template<typename T, access a>
struct texturecube_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube_array<T, a> &operator&() const thread = delete;
#endif

  const thread texturecube_array<T, a> &operator,(const thread texturecube_array<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube_array<T, a> &operator,(const device texturecube_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube_array<T, a> &operator,(const constant texturecube_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube_array<T, a> &operator,(const thread texturecube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube_array<T, a> &operator,(const device texturecube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube_array<T, a> &operator,(const constant texturecube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texturecube_array<T, a> &operator,(const thread texturecube_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texturecube_array<T, a> &operator,(const device texturecube_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texturecube_array<T, a> &operator,(const constant texturecube_array<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texturecube_array() thread : t(__metal_get_null_texture_cube_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texturecube_array() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texturecube_array() constant : t(__metal_get_null_texture_cube_array_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texturecube_array() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube_array<T, a> &operator=(const thread texturecube_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube_array<T, a> &operator=(const thread texturecube_array<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube_array<T, a> &operator=(const device texturecube_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube_array<T, a> &operator=(const device texturecube_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texturecube_array<T, a> &operator=(const constant texturecube_array<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texturecube_array<T, a> &operator=(const constant texturecube_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube_array<T, a> &operator=(const thread texturecube_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube_array<T, a> &operator=(const thread texturecube_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube_array<T, a> &operator=(const device texturecube_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube_array<T, a> &operator=(const device texturecube_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texturecube_array<T, a> &operator=(const constant texturecube_array<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texturecube_array<T, a> &operator=(const constant texturecube_array<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    return __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_read(a), _err_read_access_msg);
    bool nack;
    vec<T, 4> v = __metal_read_texture_cube_array_t(t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    return __metal_write_texture_cube_array_t(t, coord, face, array, color, lod, int(a));
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template<typename E, typename L>
  METAL_FUNC void write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_write(a), _err_write_access_msg);
    static_assert(_is_valid_imageblock_slice_write(E, T), _err_imageblock_slice_write_msg);
    __metal_write_imageblock_slice_to_texture_cube_array_t(t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a));
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_texture_cube_array_t(t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_cube_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_cube_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_cube_array_t(t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    return __metal_get_array_size_texture_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_texture_cube_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    return __metal_get_array_size_texture_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_texture_cube_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_texture_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    return __metal_get_array_size_texture_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_texture_cube_array_t(t);
  }
#endif

private:
  __metal_texture_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube_array<T, a>);
#endif
};
#endif // defined(__HAVE_TEXTURE_CUBE_ARRAY__)

template<typename T, access a>
struct texture2d_ms<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_ms_access(a), _err_ms_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_ms<T, a> &operator&() const thread = delete;
#endif

  const thread texture2d_ms<T, a> &operator,(const thread texture2d_ms<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_ms<T, a> &operator,(const device texture2d_ms<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_ms<T, a> &operator,(const constant texture2d_ms<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_ms<T, a> &operator,(const thread texture2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_ms<T, a> &operator,(const device texture2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_ms<T, a> &operator,(const constant texture2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture2d_ms<T, a> &operator,(const thread texture2d_ms<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture2d_ms<T, a> &operator,(const device texture2d_ms<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture2d_ms<T, a> &operator,(const constant texture2d_ms<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d_ms() thread : t(__metal_get_null_texture_2d_ms_t())
  {
  }
#else
  texture2d_ms() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture2d_ms() constant : t(__metal_get_null_texture_2d_ms_t())
  {
  }
#else
  texture2d_ms() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_ms<T, a> &operator=(const thread texture2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread texture2d_ms<T, a> &operator=(const thread texture2d_ms<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_ms<T, a> &operator=(const device texture2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread texture2d_ms<T, a> &operator=(const device texture2d_ms<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture2d_ms<T, a> &operator=(const constant texture2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread texture2d_ms<T, a> &operator=(const constant texture2d_ms<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_ms<T, a> &operator=(const thread texture2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device texture2d_ms<T, a> &operator=(const thread texture2d_ms<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_ms<T, a> &operator=(const device texture2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device texture2d_ms<T, a> &operator=(const device texture2d_ms<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture2d_ms<T, a> &operator=(const constant texture2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device texture2d_ms<T, a> &operator=(const constant texture2d_ms<T, a> &) device = delete;
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const thread
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const thread
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const device
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const device
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const constant
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const constant
  {
    return __metal_read_texture_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    vec<T, 4> v = __metal_read_texture_2d_ms_t(t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width() const thread
  {
    return __metal_get_width_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const thread
  {
    return __metal_get_height_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    return __metal_get_num_samples_texture_2d_ms_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    return __metal_get_width_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const device
  {
    return __metal_get_height_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    return __metal_get_num_samples_texture_2d_ms_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    return __metal_get_width_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const constant
  {
    return __metal_get_height_texture_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    return __metal_get_num_samples_texture_2d_ms_t(t);
  }
#endif

private:
  __metal_texture_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms<T, a>);
#endif
};


#if defined(__HAVE_TEXTURE_BUFFER__)
template<typename T, access a>
struct texture_buffer<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_texture_buffer_access(a), _err_texture_buffer_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture_buffer<T, a> &operator&() const thread = delete;
#endif

  const thread texture_buffer<T, a> &operator,(const thread texture_buffer<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture_buffer<T, a> &operator,(const device texture_buffer<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture_buffer<T, a> &operator,(const constant texture_buffer<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture_buffer<T, a> &operator,(const thread texture_buffer<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture_buffer<T, a> &operator,(const device texture_buffer<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture_buffer<T, a> &operator,(const constant texture_buffer<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread texture_buffer<T, a> &operator,(const thread texture_buffer<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device texture_buffer<T, a> &operator,(const device texture_buffer<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant texture_buffer<T, a> &operator,(const constant texture_buffer<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture_buffer() thread : t(__metal_get_null_texture_buffer_1d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture_buffer() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC texture_buffer() constant : t(__metal_get_null_texture_buffer_1d_t())
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_default_construct(a), _err_default_construct_msg);
  }
#else
  texture_buffer() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture_buffer<T, a> &operator=(const thread texture_buffer<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture_buffer<T, a> &operator=(const thread texture_buffer<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture_buffer<T, a> &operator=(const device texture_buffer<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture_buffer<T, a> &operator=(const device texture_buffer<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread texture_buffer<T, a> &operator=(const constant texture_buffer<T, a> &that) thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  thread texture_buffer<T, a> &operator=(const constant texture_buffer<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture_buffer<T, a> &operator=(const thread texture_buffer<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture_buffer<T, a> &operator=(const thread texture_buffer<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture_buffer<T, a> &operator=(const device texture_buffer<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture_buffer<T, a> &operator=(const device texture_buffer<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device texture_buffer<T, a> &operator=(const constant texture_buffer<T, a> &that) device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_copy_assign(a), _err_copy_assign_msg);
    t = that.t;
    return *this;
  }
#else
  device texture_buffer<T, a> &operator=(const constant texture_buffer<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC uint get_width() const thread
  {
    return __metal_get_width_texture_buffer_1d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    return __metal_get_width_texture_buffer_1d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    return __metal_get_width_texture_buffer_1d_t(t);
  }
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const thread
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const thread
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const device
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const device
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const constant
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const constant
  {
    return __metal_read_texture_buffer_1d_t(t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const thread
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const thread
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const device
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const device
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const constant
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const constant
  {
    __metal_write_texture_buffer_1d_t(t, coord, color, int(a));
  }

  METAL_FUNC void fence() thread
  {
    __metal_fence_texture_buffer_1d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    __metal_fence_texture_buffer_1d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    __metal_fence_texture_buffer_1d_t(t);
  }
#endif

private:
  __metal_texture_buffer_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture_buffer<T, a>);
#endif
};
#endif // defined(__HAVE_TEXTURE_BUFFER__)

template<typename T, access a>
struct depth2d<T, a, typename enable_if<is_depth_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_depth_access(a), _err_depth_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d<T, a> &operator&() const thread = delete;
#endif

  const thread depth2d<T, a> &operator,(const thread depth2d<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d<T, a> &operator,(const device depth2d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d<T, a> &operator,(const constant depth2d<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d<T, a> &operator,(const thread depth2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d<T, a> &operator,(const device depth2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d<T, a> &operator,(const constant depth2d<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d<T, a> &operator,(const thread depth2d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d<T, a> &operator,(const device depth2d<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d<T, a> &operator,(const constant depth2d<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d() thread : t(__metal_get_null_depth_2d_t())
  {
  }
#else
  depth2d() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d() constant : t(__metal_get_null_depth_2d_t())
  {
  }
#else
  depth2d() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d<T, a> &operator=(const thread depth2d<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d<T, a> &operator=(const thread depth2d<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d<T, a> &operator=(const device depth2d<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d<T, a> &operator=(const device depth2d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d<T, a> &operator=(const constant depth2d<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d<T, a> &operator=(const constant depth2d<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d<T, a> &operator=(const thread depth2d<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d<T, a> &operator=(const thread depth2d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d<T, a> &operator=(const device depth2d<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d<T, a> &operator=(const device depth2d<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d<T, a> &operator=(const constant depth2d<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d<T, a> &operator=(const constant depth2d<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t(t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const thread
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const thread
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const device
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const device
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const constant
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const constant
  {
    return __metal_read_depth_2d_t(t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_t(t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_t(t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_depth_2d_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_depth_2d_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_depth_2d_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_depth_2d_t(t);
  }
#endif

private:
  __metal_depth_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d<T, a>);
#endif
};

template<typename T, access a>
struct depth2d_array<T, a, typename enable_if<is_depth_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_depth_access(a), _err_depth_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_array<T, a> &operator&() const thread = delete;
#endif

  const thread depth2d_array<T, a> &operator,(const thread depth2d_array<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_array<T, a> &operator,(const device depth2d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_array<T, a> &operator,(const constant depth2d_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_array<T, a> &operator,(const thread depth2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_array<T, a> &operator,(const device depth2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_array<T, a> &operator,(const constant depth2d_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_array<T, a> &operator,(const thread depth2d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_array<T, a> &operator,(const device depth2d_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_array<T, a> &operator,(const constant depth2d_array<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d_array() thread : t(__metal_get_null_depth_2d_array_t())
  {
  }
#else
  depth2d_array() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d_array() constant : t(__metal_get_null_depth_2d_array_t())
  {
  }
#else
  depth2d_array() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_array<T, a> &operator=(const thread depth2d_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_array<T, a> &operator=(const thread depth2d_array<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_array<T, a> &operator=(const device depth2d_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_array<T, a> &operator=(const device depth2d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_array<T, a> &operator=(const constant depth2d_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_array<T, a> &operator=(const constant depth2d_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_array<T, a> &operator=(const thread depth2d_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_array<T, a> &operator=(const thread depth2d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_array<T, a> &operator=(const device depth2d_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_array<T, a> &operator=(const device depth2d_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_array<T, a> &operator=(const constant depth2d_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_array<T, a> &operator=(const constant depth2d_array<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t(t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_2d_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_2d_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const thread
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const device
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const constant
  {
    return __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_array_t(t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_2d_array_t(t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    return __metal_get_array_size_depth_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_depth_2d_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    return __metal_get_array_size_depth_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_depth_2d_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_depth_2d_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    return __metal_get_array_size_depth_2d_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_depth_2d_array_t(t);
  }
#endif

private:
  __metal_depth_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_array<T, a>);
#endif
};

template<typename T, access a>
struct depthcube<T, a, typename enable_if<is_depth_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_depth_access(a), _err_depth_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube<T, a> &operator&() const thread = delete;
#endif

  const thread depthcube<T, a> &operator,(const thread depthcube<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube<T, a> &operator,(const device depthcube<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube<T, a> &operator,(const constant depthcube<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube<T, a> &operator,(const thread depthcube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube<T, a> &operator,(const device depthcube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube<T, a> &operator,(const constant depthcube<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube<T, a> &operator,(const thread depthcube<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube<T, a> &operator,(const device depthcube<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube<T, a> &operator,(const constant depthcube<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depthcube() thread : t(__metal_get_null_depth_cube_t())
  {
  }
#else
  depthcube() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depthcube() constant : t(__metal_get_null_depth_cube_t())
  {
  }
#else
  depthcube() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube<T, a> &operator=(const thread depthcube<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube<T, a> &operator=(const thread depthcube<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube<T, a> &operator=(const device depthcube<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube<T, a> &operator=(const device depthcube<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube<T, a> &operator=(const constant depthcube<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube<T, a> &operator=(const constant depthcube<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube<T, a> &operator=(const thread depthcube<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube<T, a> &operator=(const thread depthcube<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube<T, a> &operator=(const device depthcube<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube<T, a> &operator=(const device depthcube<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube<T, a> &operator=(const constant depthcube<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube<T, a> &operator=(const constant depthcube<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC T sample(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t(t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_t_grad(t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t(t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_t_grad(t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif

#if defined(__HAVE_DEPTH_CUBE_READ__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const thread
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const device
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const constant
  {
    return __metal_read_depth_cube_t(t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_cube_t(t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_t(t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_t(t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_t(t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_t(t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_t(t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_t(t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_depth_cube_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_depth_cube_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_depth_cube_t(t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_depth_cube_t(t);
  }
#endif

private:
  __metal_depth_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube<T, a>);
#endif
};

#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template<typename T, access a>
struct depthcube_array<T, a, typename enable_if<is_depth_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_depth_access(a), _err_depth_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube_array<T, a> &operator&() const thread = delete;
#endif

  const thread depthcube_array<T, a> &operator,(const thread depthcube_array<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube_array<T, a> &operator,(const device depthcube_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube_array<T, a> &operator,(const constant depthcube_array<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube_array<T, a> &operator,(const thread depthcube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube_array<T, a> &operator,(const device depthcube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube_array<T, a> &operator,(const constant depthcube_array<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depthcube_array<T, a> &operator,(const thread depthcube_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depthcube_array<T, a> &operator,(const device depthcube_array<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depthcube_array<T, a> &operator,(const constant depthcube_array<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depthcube_array() thread : t(__metal_get_null_depth_cube_array_t())
  {
  }
#else
  depthcube_array() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depthcube_array() constant : t(__metal_get_null_depth_cube_array_t())
  {
  }
#else
  depthcube_array() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube_array<T, a> &operator=(const thread depthcube_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube_array<T, a> &operator=(const thread depthcube_array<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube_array<T, a> &operator=(const device depthcube_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube_array<T, a> &operator=(const device depthcube_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depthcube_array<T, a> &operator=(const constant depthcube_array<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depthcube_array<T, a> &operator=(const constant depthcube_array<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube_array<T, a> &operator=(const thread depthcube_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube_array<T, a> &operator=(const thread depthcube_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube_array<T, a> &operator=(const device depthcube_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube_array<T, a> &operator=(const device depthcube_array<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depthcube_array<T, a> &operator=(const constant depthcube_array<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depthcube_array<T, a> &operator=(const constant depthcube_array<T, a> &) device = delete;
#endif
#endif

  METAL_FUNC T sample(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t(t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_depth_cube_array_t_grad(t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    return __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_sample(a), _err_sample_access_msg);
    bool nack;
    T v = __metal_sample_compare_depth_cube_array_t_grad(t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    return __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    bool nack;
    T v = __metal_read_depth_cube_array_t(t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_depth_cube_array_t(t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    return __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    // TODO: Using static assert prevents usage of SFINAE. We need to remove it
    // -- see <rdar://problem/31769738>.
    static_assert(_is_valid_gather(a), _err_gather_access_msg);
    bool nack;
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    return __metal_get_width_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    return __metal_get_height_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    return __metal_get_array_size_depth_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    return __metal_get_num_mip_levels_depth_cube_array_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    return __metal_get_width_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    return __metal_get_height_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    return __metal_get_array_size_depth_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    return __metal_get_num_mip_levels_depth_cube_array_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    return __metal_get_width_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    return __metal_get_height_depth_cube_array_t(t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    return __metal_get_array_size_depth_cube_array_t(t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    return __metal_get_num_mip_levels_depth_cube_array_t(t);
  }
#endif

private:
  __metal_depth_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube_array<T, a>);
#endif
};
#endif // defined(__HAVE_DEPTH_CUBE_ARRAY__)

template<typename T, access a>
struct depth2d_ms<T, a, typename enable_if<is_depth_texture_channel<T>::value>::type>
{
  // TODO: Using static assert prevents usage of SFINAE. We need to remove it
  // -- see <rdar://problem/31769738>.
  static_assert(_is_valid_ms_access(a), _err_ms_access);
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_ms<T, a> &operator&() const thread = delete;
#endif

  const thread depth2d_ms<T, a> &operator,(const thread depth2d_ms<T, a> &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_ms<T, a> &operator,(const device depth2d_ms<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_ms<T, a> &operator,(const constant depth2d_ms<T, a> &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_ms<T, a> &operator,(const thread depth2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_ms<T, a> &operator,(const device depth2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_ms<T, a> &operator,(const constant depth2d_ms<T, a> &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread depth2d_ms<T, a> &operator,(const thread depth2d_ms<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device depth2d_ms<T, a> &operator,(const device depth2d_ms<T, a> &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant depth2d_ms<T, a> &operator,(const constant depth2d_ms<T, a> &) const constant = delete;
#endif

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d_ms() thread : t(__metal_get_null_depth_2d_ms_t())
  {
  }
#else
  depth2d_ms() thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_NULL_TEXTURE__)
  METAL_FUNC depth2d_ms() constant : t(__metal_get_null_depth_2d_ms_t())
  {
  }
#else
  depth2d_ms() constant = delete;
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_ms<T, a> &operator=(const thread depth2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_ms<T, a> &operator=(const thread depth2d_ms<T, a> &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_ms<T, a> &operator=(const device depth2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_ms<T, a> &operator=(const device depth2d_ms<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC thread depth2d_ms<T, a> &operator=(const constant depth2d_ms<T, a> &that) thread
  {
    t = that.t;
    return *this;
  }
#else
  thread depth2d_ms<T, a> &operator=(const constant depth2d_ms<T, a> &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_ms<T, a> &operator=(const thread depth2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_ms<T, a> &operator=(const thread depth2d_ms<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_ms<T, a> &operator=(const device depth2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_ms<T, a> &operator=(const device depth2d_ms<T, a> &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
  METAL_FUNC device depth2d_ms<T, a> &operator=(const constant depth2d_ms<T, a> &that) device
  {
    t = that.t;
    return *this;
  }
#else
  device depth2d_ms<T, a> &operator=(const constant depth2d_ms<T, a> &) device = delete;
#endif
#endif

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const thread
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const thread
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const device
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const device
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const constant
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const constant
  {
    return __metal_read_depth_2d_ms_t(t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    T v = __metal_read_depth_2d_ms_t(t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC uint get_width() const thread
  {
    return __metal_get_width_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const thread
  {
    return __metal_get_height_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    return __metal_get_num_samples_depth_2d_ms_t(t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    return __metal_get_width_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const device
  {
    return __metal_get_height_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    return __metal_get_num_samples_depth_2d_ms_t(t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    return __metal_get_width_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_height() const constant
  {
    return __metal_get_height_depth_2d_ms_t(t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    return __metal_get_num_samples_depth_2d_ms_t(t);
  }
#endif

private:
  __metal_depth_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms<T, a>);
#endif
};


#if defined(__HAVE_NULL_TEXTURE__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d<T, a> tex)
{
  return __metal_is_null_texture_1d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex)
{
  return __metal_is_null_texture_1d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d<T, a> tex)
{
  return __metal_is_null_texture_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex)
{
  return __metal_is_null_texture_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture3d<T, a> tex)
{
  return __metal_is_null_texture_3d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube<T, a> tex)
{
  return __metal_is_null_texture_cube_t(tex.t);
}
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex)
{
  return __metal_is_null_texture_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex)
{
  return __metal_is_null_texture_2d_ms_t(tex.t);
}
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex)
{
  return __metal_is_null_texture_buffer_1d_t(tex.t);
}
#endif // defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d<T, a> tex)
{
  return __metal_is_null_depth_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex)
{
  return __metal_is_null_depth_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube<T, a> tex)
{
  return __metal_is_null_depth_cube_t(tex.t);
}
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex)
{
  return __metal_is_null_depth_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex)
{
  return __metal_is_null_depth_2d_ms_t(tex.t);
}
#endif // defined(__HAVE_NULL_TEXTURE__)

} // namespace metal
#pragma METAL internals : disable

#endif // __METAL_TEXTURE
